/*    AUTORES:*   Ignacio Borregan Naya :ignacio.borregan*   Carlos Iglesias Gomez :carlos.iglesias1*   GRUPO: 32*/#include <stdio.h>#include <string.h>#include <unistd.h>#include <grp.h>#include <pwd.h>#include <time.h>#include <stdlib.h>#include <sys/stat.h>#include <errno.h>#include <dirent.h>#include <fcntl.h>#include <sys/shm.h>#include <sys/mman.h>#include <signal.h>#include <sys/resource.h>#include <sys/wait.h>#include <signal.h>#include "lista.h"#include "listaprocs.h"#define ACTIVO 0xffff#define MAX 500#define MAXH 4096 //maximo del array utilizado en hist#define TAMANO 2048#define LEERCOMPLETO ((ssize_t)-1)int x=0, y=0, z=0;/*CABECERAS*/  /*funciones dadas por la practica*/  int TrocearCadena(char * cadena, char * trozos[]);  char TipoFichero (mode_t m);  char * ConvierteModo2 (mode_t m);  /*Funciones p0*/  int opcion(char *cadena[]);  void autores(char *trozos[]);  void processID(char *trozos[]);  void cdir(char *trozos[]);  void fecha();  void hora();  int hisLength(char *his[]);  void pointar(char *copia, char *his[]);  void emptyHist(char *his[]);  void hist(char *trozos[], char *his[]);  void inicializarHistorico(char *his[]);  /*Funciones p1*/  void crear(char *trozos[]);  void recRemove(char trozos[]);  void borrar(char *trozos[]);  void infoli(char name[]);  void info(char *trozos[], int nNames);  void opListar(int l, int v, int r, char dir[]);  void listar(char *trozos[], int nTrozos);  /*Funciones p2*/  void listarAsignar(lista * l, int tipo);  void recursiva (int n);  void mem(char *trozos[],int nTrozos, lista * l);  void rfich(char *trozos[], int nTrozos);  void wfich(char *trozos[], int nTrozos);  void llenar(char * trozos[]);  /*Funciones p3*/  void priority (char *trozos[]);  void crearProceso();  /*funciones Main*/  void printPrompt();  void leerEntrada(char *orden);  void procesarEntrada(char *orden,char *trozos[],char *his[], lista * l, listaP * lp);/**********************************************************************/int TrocearCadena(char * cadena, char * trozos[]){  int i=1;  if ((trozos[0]=strtok(cadena," \n\t"))==NULL) //se trocea la cadena utilizando como delimitador los espacios  return 0;  while ((trozos[i]=strtok(NULL," \n\t"))!=NULL)i++;  return i;}/*****************************************************************/char TipoFichero (mode_t m){  switch (m&S_IFMT) { /*and bit a bit con los bits de formato,0170000 */    case S_IFSOCK: return 's';  /*socket*/    case S_IFLNK: return 'l';   /*symbolic link*/    case S_IFREG: return '-';   /*fichero normal*/    case S_IFBLK: return 'b';   /*block device*/    case S_IFDIR: return 'd';   /*directorio */    case S_IFCHR: return 'c';   /*char  device*/    case S_IFIFO: return 'p';   /*pipe*/    default: return '?';    /*desconocido, no deberia aparecer*/  }}/******************************************************************/char * ConvierteModo2 (mode_t m){  static char permisos[12];  strcpy (permisos, "---------- ");  permisos[0]= TipoFichero(m);  if (m&S_IRUSR) permisos[1]='r';  if (m&S_IWUSR) permisos[2]='w';  if (m&S_IXUSR) permisos[3]='x';  if (m&S_IRGRP) permisos[4]='r';  if (m&S_IWGRP) permisos[5]='w';  if (m&S_IXGRP) permisos[6]='x';  if (m&S_IROTH) permisos[7]='r';  if (m&S_IWOTH) permisos[8]='w';  if (m&S_IXOTH) permisos[9]='x';  if (m&S_ISUID) permisos[3]='s';  if (m&S_ISGID) permisos[6]='s';  if (m&S_ISVTX) permisos[9]='t';  return (permisos);}/******************************************************************/struct SEN{  char *nombre;  int senal;};/*************************************************************/static struct SEN sigstrnum[]={	{"HUP", SIGHUP},	{"INT", SIGINT},	{"QUIT", SIGQUIT},	{"ILL", SIGILL},	{"TRAP", SIGTRAP},	{"ABRT", SIGABRT},	{"IOT", SIGIOT},	{"BUS", SIGBUS},	{"FPE", SIGFPE},	{"KILL", SIGKILL},	{"USR1", SIGUSR1},	{"SEGV", SIGSEGV},	{"USR2", SIGUSR2},	{"PIPE", SIGPIPE},	{"ALRM", SIGALRM},	{"TERM", SIGTERM},	{"CHLD", SIGCHLD},	{"CONT", SIGCONT},	{"STOP", SIGSTOP},	{"TSTP", SIGTSTP},	{"TTIN", SIGTTIN},	{"TTOU", SIGTTOU},	{"URG", SIGURG},	{"XCPU", SIGXCPU},	{"XFSZ", SIGXFSZ},	{"VTALRM", SIGVTALRM},	{"PROF", SIGPROF},	{"WINCH", SIGWINCH},	{"IO", SIGIO},	{"SYS", SIGSYS},/*senales que no hay en todas partes*/#ifdef SIGPOLL	{"POLL", SIGPOLL},#endif#ifdef SIGPWR	{"PWR", SIGPWR},#endif#ifdef SIGEMT	{"EMT", SIGEMT},#endif#ifdef SIGINFO	{"INFO", SIGINFO},#endif#ifdef SIGSTKFLT	{"STKFLT", SIGSTKFLT},#endif#ifdef SIGCLD	{"CLD", SIGCLD},#endif#ifdef SIGLOST	{"LOST", SIGLOST},#endif#ifdef SIGCANCEL	{"CANCEL", SIGCANCEL},#endif#ifdef SIGTHAW	{"THAW", SIGTHAW},#endif#ifdef SIGFREEZE	{"FREEZE", SIGFREEZE},#endif#ifdef SIGLWP	{"LWP", SIGLWP},#endif#ifdef SIGWAITING	{"WAITING", SIGWAITING},#endif	{NULL,-1},};/******************************************************************/int Senal(char * sen) {  int i;  for (i=0; sigstrnum[i].nombre!=NULL; i++)    if (!strcmp(sen, sigstrnum[i].nombre))      return sigstrnum[i].senal;  return -1;}/*****************************************************************/char *NombreSenal(int sen){  /*devuelve el nombre senal a partir de la senal*//* para sitios donde no hay sig2str*/	int i;	for (i=0; sigstrnum[i].nombre!=NULL; i++)		if (sen==sigstrnum[i].senal)			return sigstrnum[i].nombre;	return ("SIGUNKNOWN");}/*****************************************************************/int opcion(char *cadena[]) {  if(*cadena != NULL){    if (!strcmp(cadena[0],"autores"))      return 1;    else if (!strcmp(cadena[0],"pid"))      return 2;    else if (!strcmp(cadena[0],"cdir"))      return 3;    else if (!strcmp(cadena[0],"fecha"))      return 4;    else if (!strcmp(cadena[0],"hora"))      return 5;    else if (!strcmp(cadena[0],"hist"))      return 6;    else if (!strcmp(cadena[0],"fin")||!strcmp(cadena[0],"end")||!strcmp(cadena[0],"exit")) //se pone || ya que la hacen lo ismo      return 0;    else if(!strcmp(cadena[0],"crear"))      return 9;    else if(!strcmp(cadena[0],"borrar"))      return 10;    else if(!strcmp(cadena[0],"info"))      return 11;    else if(!strcmp(cadena[0],"listar"))      return 12;    else if(!strcmp(cadena[0],"asignar"))      return 13;    else if(!strcmp(cadena[0],"desasignar"))      return 14;    else if(!strcmp(cadena[0],"recursiva"))      return 15;    else if(!strcmp(cadena[0],"mem"))      return 16;    else if(!strcmp(cadena[0],"rfich"))      return 17;    else if(!strcmp(cadena[0],"wfich"))      return 18;    else if(!strcmp(cadena[0],"llenar"))      return 19;    else if(!strcmp(cadena[0],"volcar"))      return 20;    else if(!strcmp(cadena[0],"priority"))      return 21;    else if(!strcmp(cadena[0],"fork"))      return 22;    else if(!strcmp(cadena[0],"exec"))      return 23;    else if(!strcmp(cadena[0],"pplano"))      return 24;    else if(!strcmp(cadena[0],"splano"))      return 25;    else if(!strcmp(cadena[0],"listarprocs"))      return 26;    else if(!strcmp(cadena[0],"proc"))      return 27;    else if(!strcmp(cadena[0],"borrarprocs"))      return 28;    else      return 8;  }else  return 7;}/*****************************************************************/void autores(char *trozos[]){  if ((trozos[0]==NULL)||!strcmp(trozos[0],"-n")) { //la ausencia de opcion imprime    printf("Ignacio Borregan Naya\n ");             //la combinacion de -n y -l    printf("Carlos Iglesias Gomez\n");   }    if((trozos[0]==NULL)||!strcmp(trozos[0],"-l")){    printf(" ignacio.borregan\n");    printf(" carlos.iglesias1\n");  }}/*****************************************************************/void processID(char *trozos[]){  if (trozos[0]==NULL){    printf("Pid del shell : %d\n", getpid());  } else if (!strcmp(trozos[0],"-p")) {    printf("Pid del padre del shell: %d\n", getppid());  }//else    //printf("Invalid option %s\n",trozos[0]);}/*****************************************************************/void cdir(char *trozos[]){  char direccion [100];  if (trozos[0]==NULL){    printf("Ahora estas en %s\n", getcwd(direccion, 100));  }else{    if (chdir(trozos[0])!=0){      printf("Error: no existe la ruta especificada\n");    }  }}/******************************************************************/void fecha(){  time_t t = time(NULL);      struct tm *tm = localtime(&t);      char date[MAX];      strftime(date,MAX,"%a %b %2d %2H:%2M:%2S %Y",tm);      printf("%s\n",date);}/*****************************************************************/void hora(){  time_t t = time(NULL);      struct tm *tm = localtime(&t);      char hour[MAX];      strftime(hour,MAX,"%2H:%2M:%2S",tm);      printf("%s\n",hour);}/******************************************************************/void crear(char *trozos[]) {  //  si es un nombre crea un fichero txt si es -d y un nombre, crea una carpeta  //  y si es -d pero no name lista el directorio  //  listar directorio  if(trozos[0]==NULL){      opListar(0, 0, 0,".");  } else if (!strcmp(trozos[0],"-d")){      if(trozos[1]==NULL){        opListar(0, 0, 0,".");      }else {          if(mkdir(trozos[1], 0775)==-1){            perror("Imposible crear ");          }      }  }else{    if (open(trozos[0],O_CREAT | O_EXCL, 0775 )== -1) {      perror("Imposible crear ");    }  }}/******************************************************************/void recRemove(char trozos[]) {  DIR *direc = opendir(trozos);  struct dirent *de;  struct stat stats;  char aux[MAX]="";  if(direc == NULL){    perror("Imposible borrar");  }else{    for (de = readdir(direc); de!=NULL; de=readdir(direc)) {      strcpy(aux,strcat(trozos,"/"));      strcpy(aux,strcat(aux,de -> d_name));      lstat(aux,&stats);      if (TipoFichero(stats.st_mode) != 'd'){        remove(aux);      } else if(strcmp(de -> d_name,".") != 0 && strcmp(de -> d_name,"..") != 0){          recRemove(aux);        }    }    closedir(direc);    if (remove(trozos)!=0) {      perror("Imposible borrar");    }  }}/******************************************************************/void borrar(char *trozos[]){  // si -r y name borra el directorio y todos sus contenidos  // si solo name se borra el dir solo si esta vacio ese dir  //si -r y nombre de archivo, borra el archivo  //si ningun nombre -> listDir  if(trozos[0]==NULL){      opListar(0, 0, 0,".");  } else if (!strcmp(trozos[0],"-r")){        if(trozos[1]==NULL){          opListar(0, 0, 0,".");        }else {            recRemove(trozos[1]);        }    }else{      if(remove(trozos[0])!=0){        perror("Imposible borrar ");        //printf("Imposible borrar : %s \n", strerror(EEXIST) );      }    }}/*****************************************************************/void infoli(char name[]) {struct group *grp;struct passwd *pwd;struct stat stats;char date[MAX]="";char aux[MAX]="";if(stat(name,&stats)==-1){  strcpy(aux,"Cannot access ");  strcat(aux,name);  perror(aux);}else {    grp = getgrgid(stats.st_gid);    pwd = getpwuid(stats.st_uid);    printf("%5ld ", stats.st_ino);  //num de inodo    printf("%5s", ConvierteModo2(stats.st_mode));    printf("%5ld ", stats.st_nlink);  //y num de links    printf("%5s", pwd->pw_name);    printf("%5s ", grp->gr_name);    printf("%5ld ", stats.st_size);    strftime(date, MAX, "%a %b %2d %2H:%2M %Y", gmtime(&(stats.st_ctime)));    printf("%5s", date);    if (TipoFichero(stats.st_mode)=='l') {      printf("%5s -> %s \n", name, realpath(name,NULL));    } else {      printf(" %5s\n", name);    }  }}/*****************************************************************/void info(char *trozos[], int nNames) {  // name 1 name 2 y name 3 son los files o dir para dar info  //y una linea de output por cada name como con  el comando ls -li  //es decir que ahi estaria bien un for e ir haciendo el listar  //de cada trozos[i]  //IMPRESION -> numero de inodo permisos links usuario grupo tamano ultima_modificacion  if (nNames!=1) {    for (int i = 1; i < nNames; i++) {        infoli(trozos[i]);    }  }}/******************************************************************/void opListar(int l, int v, int r, char dir[]) {  DIR *d;  struct dirent *di;  struct stat sstats;  char aux[MAX]="";  char namel[MAX]="";  strcpy(namel,dir);    printf("********* %s\n", namel);  d = opendir(dir);  if (d) {    while ((di = readdir(d)) != NULL) {      strcpy(namel,dir);      strcat(namel, "/");      strcat(namel, di->d_name);      stat(namel, &sstats);      if (!(v&&((!strcmp(di ->d_name, "."))||(!strcmp(di ->d_name, ".."))))) {        if (l) {          infoli (namel);        }else{          printf("%s %ld\n", di->d_name, sstats.st_size);        }        if(r&&(TipoFichero(sstats.st_mode)== 'd')) {          if(strcmp(di -> d_name,".") != 0 && strcmp(di -> d_name,"..") != 0){            //strcpy(aux,strcat(dir,"/"));            //strcpy(aux,strcat(aux,di -> d_name));           strcpy(aux, dir);           strcat(aux, "/");           strcat(aux, di->d_name);           //strcpy(aux,di -> d_name);           opListar(l,v,r,aux);          }        }      }    }    closedir(d);  }else{    perror("Error al listar directorio");  }}/******************************************************************/void listar(char *trozos[], int nTrozos) {  int flagv = 0, flagl=0, flagr=0, i=0; // lopcion=0  if(nTrozos!=1){    while (i==0) {        if(!strcmp(trozos[0],"-l")){            flagl=1;            trozos=trozos+1;            nTrozos-=1;          } else if(!strcmp(trozos[0],"-v")){            flagv=1;            trozos=trozos+1;            nTrozos-=1;          } else if (!strcmp(trozos[0],"-r")){            flagr=1;            trozos=trozos+1;            nTrozos-=1;          } else {            i=1;          }          if(nTrozos==1) i=1;      }      //lopcion=flagl+flagv+flagr;    }      nTrozos-=1;      if(nTrozos==0){        opListar(flagl,flagv,flagr,".");      }      else{        for (int i = 0; i < nTrozos; i++) {          opListar(flagl,flagv,flagr,trozos[i]);        }      }    }/*****************************************************************/void * ObtenerMemoriaShmget (key_t clave, size_t tam, lista * l){  void * p;  int aux,id,flags=0777;  struct shmid_ds s;  if (tam)  /*si tam no es 0 la crea en modo exclusivo */  flags=flags | IPC_CREAT | IPC_EXCL;  /*si tam es 0 intenta acceder a una ya creada*/  if (clave==IPC_PRIVATE){   /*no nos vale*/    errno=EINVAL; return NULL;  }  if ((id=shmget(clave, tam, flags))==-1)    return (NULL);  if ((p=shmat(id,NULL,0))==(void*) -1){    aux=errno;   /*si se ha creado y no se puede mapear*/    if (tam)     /*se borra */      shmctl(id,IPC_RMID,NULL);    errno=aux;    return (NULL);  }  shmctl (id,IPC_STAT,&s);  /* Guardar En Direcciones de Memoria Shared (p, s.shm_segsz, clave.....);*/  tItem item;  item.direccion=&p;  item.size = s.shm_segsz;  item.fecha=time(NULL);  item.key=clave;  strcpy(item.fichero,"");  item.fd=-1;  item.tipo = 3;  inserItem(l,&item);  return (p);}/*****************************************************************/void Cmd_AsignarCreateShared (char *arg[],lista * l){  key_t k;  size_t tam=0;  void *p;  if (arg[0]==NULL || arg[1]==NULL){    listarAsignar(l,SHARED);    return;  }  k=(key_t) atoi(arg[0]);  if (arg[1]!=NULL)    tam=(size_t) atoll(arg[1]);  if ((p=ObtenerMemoriaShmget(k,tam, l))==NULL)    perror ("Imposible obtener memoria shmget");  else    printf ("Allocated shared memory (key %d) at %p\n",k,p);}/*****************************************************************/void * MmapFichero (char * fichero, int protection,lista * l){  int df, map=MAP_PRIVATE,modo=O_RDONLY;  struct stat s;  void *p;  if (protection&PROT_WRITE)    modo=O_RDWR;  if (stat(fichero,&s)==-1 || (df=open(fichero, modo))==-1)    return NULL;  if ((p=mmap (NULL,s.st_size, protection,map,df,0))==MAP_FAILED)    return NULL;  /*Guardar Direccion de Mmap (p, s.st_size,fichero,df......);*/  tItem item;  item.direccion = p;  item.size = s.st_size;  item.fecha = time(NULL);  item.key = 0;  //item.fichero=malloc(sizeof(fichero));  strcpy(item.fichero,fichero);  item.fd = df;  item.tipo = 2;  inserItem(l,&item);  return p;}/*****************************************************************/void Cmd_AsignarMmap (char *arg[],lista * l){  char *perm;  void *p;  int protection=0;  if (arg[0]==NULL){    listarAsignar(l,MAP);    return;  }  if ((perm=arg[1])!=NULL && strlen(perm)<4) {    if (strchr(perm,'r')!=NULL) protection|=PROT_READ;    if (strchr(perm,'w')!=NULL) protection|=PROT_WRITE;    if (strchr(perm,'x')!=NULL) protection|=PROT_EXEC;  }  if ((p=MmapFichero(arg[0],protection, l))==NULL)    perror ("Imposible mapear fichero");  else    printf ("fichero %s mapeado en %p\n", arg[0], p);}/*****************************************************************/void asignarMalloc(char *trozos[], lista *l){  int x=0;  if (trozos[0]==NULL){    listarAsignar(l,MALLOC);  }else if(atoi(trozos[0])!=0){    tItem it;    x=atoi(trozos[0]);    it.direccion=malloc(x);    it.size=x;    it.fecha=time(NULL);    it.key=0;    strcpy(it.fichero,"");    it.tipo=MALLOC;    printf("Has asignado %d bytes en %p\n",x ,it.direccion);    inserItem(l,&it);    //free(p1); Esto p'al desasignar  }else{      printf("No se asignan bloques de 0 bytes\n");  }}/*****************************************************************/void Cmd_rmkey (char *args[]){  key_t clave;  int id;  char *key=args[0];  if (key==NULL || (clave=(key_t) strtoul(key,NULL,10))==IPC_PRIVATE){    printf ("   rmkey  clave_valida\n");    return;  }  if ((id=shmget(clave,0,0666))==-1){    perror ("shmget: imposible obtener memoria compartida");    return;  }  if (shmctl(id,IPC_RMID,NULL)==-1)    perror ("shmctl: imposible eliminar memoria compartida\n");  else    printf("Removed key\n");}/*****************************************************************/void recursiva (int n){  char automatico[TAMANO];  static char estatico[TAMANO];  printf ("parametro n=%d en: %p.\n", n, &n);  printf ("array estatico en: %p.\n", estatico);  printf ("array automatico en: %p.\n", automatico);  n--;  if (n>0){    printf("\n");    recursiva(n);  }else{    printf("\n");  }}/*****************************************************************/int type (char *trozos[]){  if (!strcmp(trozos[0],"-malloc")){    return 1;  }else if (!strcmp(trozos[0],"-mmap")) {    return 2;  } else if ((!strcmp(trozos[0],"-shared"))||(!strcmp(trozos[0],"-createshared"))){    return 3;  }else{    return -1;  }}/*****************************************************************/void listarAsignar(lista * l, int tipo) {  int itemTipo=0;  tItem *item;  char strFecha[50];  struct tm *timer;  for (int pos = 0; pos < l->fin; pos++) {    item = getItem(*l,pos);    timer= localtime(&l->array[pos]->fecha);    strftime(strFecha,50,"%a %b %d %H:%M:%S",timer);    if (tipo==4) {    //si le pasamos 4 a la funcion va a imprimir todo       itemTipo = 4;  //porque esta asignacion hara que itemTipo==tipo sea                      //siempre cierta    }else{      itemTipo = item->tipo; //sino guarda el tipo de verdad del item    }    if (itemTipo==tipo) {      switch (item->tipo) {        case MALLOC:          printf("%p: size: %9lu. malloc %s\n", item->direccion, item->size, strFecha);            break;        case MAP:          printf("%p: size: %9lu. mmap %s (fd:%d) %s \n",item->direccion, item->size, item->fichero, item->fd, strFecha);            break;        case SHARED:        printf("%p: size: %9lu. shared memory (key %d) %s \n",item->direccion, item->size, item->key, strFecha);            break;        default:          break;      }    }  }}/*****************************************************************/void asignar(char *trozos[], int nTrozos, lista * l){  if (nTrozos==1) {    listarAsignar(l,4);  }else{    switch (type(trozos)) {      case MALLOC:            asignarMalloc(trozos+1,l);        break;      case MAP:            Cmd_AsignarMmap(trozos+1,l);        break;      case SHARED:            Cmd_AsignarCreateShared(trozos+1,l);        break;      default:        break;    }  }}/*****************************************************************/void desAsignarMalloc(void * addr,lista * l){  posicion i=findItem(*l,addr);  if(i!=-1){    free(addr);    deleteItem(l,i);  }else{    printf("No hay bloque de ese tamano asignado con malloc\n");  }}/*****************************************************************/void desAsignarMmap(char *trozos[],lista * l){  tItem * item;  void * addr=NULL;  posicion pos=0;  if(trozos[0]!=NULL){    if(findMmap(*l,trozos[0])!=-1){      pos=findMmap(*l,trozos[0]);      item=getItem(*l,pos);      if(munmap(item->direccion, item->size) == 0){        close(item->fd);        printf("block at address %p deallocated (mmap)\n", item->direccion);        deleteItem(l,pos);      }    }else{        addr= (void*)strtoul(trozos[0],NULL,16);        if (getItem(*l,findItem(*l,addr))!=NULL){          pos=findItem(*l,addr);          item=getItem(*l,pos);          if(munmap(item->direccion, item->size) == 0){            close(item->fd);            printf("block at address %p deallocated (mmap)\n", item->direccion);            deleteItem(l,pos);          }        }else{          addr=NULL;          printf("Fichero %s no mapeado\n", trozos[0]);        }      }  }else{        listarAsignar(l,MAP);  }}/*****************************************************************/void desAsignarCreateShared(char *trozos[],lista * l){  tItem * item;  key_t key;  void * addr=NULL;  posicion pos=0;  if(trozos[0]!=NULL){ //aqui trozos es la key    if(findShared(*l,strtol(trozos[0], NULL, 10))!=-1){      printf("mal\n");      key= (key_t)strtol(trozos[0], NULL, 10);      pos=findShared(*l,key);      item=getItem(*l,pos);      printf("%p\n", item->direccion);      if(shmdt(item->direccion) == 0){ //si shmdt no es valido no elimina el item de la lista        printf("block at address %p deallocated (shared)\n", item->direccion);        deleteItem(l,pos);      }      perror("");    }else{        addr= (void*)strtoul(trozos[0],NULL,16);        if (getItem(*l,findItem(*l,addr))!=NULL){          pos=findItem(*l,addr);          item=getItem(*l,pos);          if(shmdt(item->direccion) == 0){            printf("block at address %p deallocated (mmap)\n", item->direccion);            deleteItem(l,pos);          }        }else{          addr=NULL;          printf("Fichero %s no mapeado\n", trozos[0]);        }      }  }else{        listarAsignar(l,SHARED);  }}/*****************************************************************/void desasignar(char *trozos[], int nTrozos, lista * l){  int opcion=0;  size_t tam=0;  void * addr=NULL;  if (nTrozos==1) {    listarAsignar(l,4);  }else{    if(type(trozos)==-1){        addr= (void*)strtoul(trozos[0],NULL,16);      //item=getItem(*l,findItem(*l,addr));      if (getItem(*l,findItem(*l,addr))!=NULL) {        opcion=getItem(*l,findItem(*l,addr))->tipo;      }      tam=-1;    }else{      opcion=type(trozos);      if(trozos[1]!=NULL)        tam=strtol(trozos[1], NULL, 10);      if (getItem(*l,findMalloc(*l,tam))!=NULL) {        addr=getItem(*l,findMalloc(*l,tam))->direccion;      }    }    switch (opcion) {      case MALLOC:            if(getItem(*l,findItem(*l,addr))!=NULL){                desAsignarMalloc(addr,l);            }else{              printf("No hay bloque de ese tamano asignado con malloc\n");            }        break;      case MAP:            if(tam!=-1){              desAsignarMmap(trozos+1,l);            }else{              desAsignarMmap(trozos,l);            }              //fichero        break;      case SHARED:          if(type(trozos)==SHARED){            desAsignarCreateShared(trozos+1,l);          }else{            desAsignarCreateShared(trozos,l);          }            //key        break;      default:          printf("Direccion %p no asignada con malloc shared o mmap.\n", addr);          addr=NULL;        break;    }  }}/*****************************************************************/void mem(char *trozos[],int nTrozos, lista * l){  int a=0,b=0, c=0;  if(nTrozos==1){    printf("Variables locales  %p, %p, %p\n", &a,&b,&c);    printf("Variables globales %p, %p, %p\n", &x,&y,&z);    printf("Funciones programa %p, %p, %p\n", &hisLength, &leerEntrada, &printPrompt);    printf("Funciones libreria %p, %p, %p\n", &printf, &strcmp, &perror);  }else{    if (!strcmp(trozos[0],"-malloc")){      listarAsignar(l,MALLOC);    }else if(!strcmp(trozos[0],"-mmap")){      listarAsignar(l,MAP);    }else if (!strcmp(trozos[0],"-shared")){      listarAsignar(l,SHARED);    }else if (!strcmp(trozos[0],"-all")){      listarAsignar(l,4);    }  }}/*****************************************************************/ssize_t LeerFichero (char *fich, void *p, ssize_t n){ssize_t nleidos,tam=n;int df, aux;struct stat s;//n=-1 indica que se lea tod  if (stat (fich,&s)==-1 || (df=open(fich,O_RDONLY))==-1)    return ((ssize_t)-1);  if (n==LEERCOMPLETO)    tam=(ssize_t) s.st_size;  if ((nleidos=read(df,p, tam))==-1){  aux=errno;  close(df);  errno=aux;  return ((ssize_t)-1);  }close (df);return (nleidos);}/*****************************************************************/void rfich(char *trozos[], int nTrozos){  void * addr=(void *)strtoul(trozos[1],NULL,16);  char fichero[20]="";  int x=atoi(trozos[2]);  if(nTrozos<4){    printf("Faltan parámetros\n");  }else{    strcpy(fichero,trozos[0]);    printf("%p\n",&addr);    if (LeerFichero(fichero,addr,x)==-1){      perror("No se ha leido nada: ");    }    else{      printf("leidos %d bytes de %s en %p\n",x,fichero,&addr);    }  }}/*****************************************************************/ssize_t EscribirFichero (char *fich, void *p, ssize_t n){ssize_t nleidos,tam=n;int df, aux;struct stat s;//n=-1 indica que se lea tod  if (stat (fich,&s)==-1 || (df=open(fich, O_WRONLY, S_IRUSR,O_APPEND | S_IWUSR))==-1)    //df=creat(fich,  S_IRUSR | S_IWUSR);    return ((ssize_t)-1);  if (n==LEERCOMPLETO)    tam=(ssize_t) s.st_size;  if ((nleidos=write(df,p, tam))==-1){  aux=errno;  close(df);  errno=aux;  return ((ssize_t)-1);  }close (df);return (nleidos);}/*****************************************************************/ssize_t EscribirFichero1 (char *fich, void *p, ssize_t n){ssize_t nleidos,tam=n;int df, aux;struct stat s;//n=-1 indica que se lea todo  if (stat (fich,&s)==-1 || (df=creat(fich,  S_IRWXU | S_IRWXG | S_IRWXO)==-1))    return ((ssize_t)-1);  if (n==LEERCOMPLETO)    tam=(ssize_t) s.st_size;  if ((nleidos=write(df,p, tam))==-1){  aux=errno;  close(df);  errno=aux;  return ((ssize_t)-1);  }close (df);return (nleidos);}/*****************************************************************/void wfich(char *trozos[], int nTrozos){  void * addr=NULL;  char fichero[20]="";  int x=0;  if(nTrozos<4){    printf("Faltan parámetros\n");  }else{    switch(nTrozos){      case 5:if(!strcmp(trozos[0],"-o")){                strcpy(fichero,trozos[1]);                addr=(void *)strtoul(trozos[2],NULL,16);                x=atoi(trozos[3]);                if (EscribirFichero(fichero,addr,x)==-1){                  perror("No se ha escrito nada: ");                }else{                  printf("Escritos %d bytes de %s en %p\n",x,fichero,&addr);                }              }              else{                perror("Error: ");              }            break;      case 4:            strcpy(fichero,trozos[0]);            addr=(void *)strtoul(trozos[1],NULL,16);            x=atoi(trozos[2]);            if (EscribirFichero(fichero,addr,x)==-1){              perror("No se ha escrito nada: ");            }else{              printf("Escritos %d bytes de %s en %p\n",x, fichero,&addr);            }        break;    default: printf("Faltan parametros\n");        break;    }  }}/*****************************************************************/void encher(char * dir, int cont, char byte){  memset(dir,byte,cont);}/*****************************************************************/void llenar(char * trozos[]){  void * addr=(void *) strtoul(trozos[0],NULL,16);  int x=128;  char letra='A';  if (trozos[1]!=NULL){    x=atoi(trozos[1]);  }  if (trozos[2]!=NULL){    strcpy(&letra,trozos[2]);  }  encher(addr,x,letra);}/*****************************************************************/void sacararray(char * dir, int cont){  //fgets(dir);  for (int i = 0; i < cont; ++i)  {    printf("%c\n",dir[i]);  }}/*****************************************************************/void volcar(char * trozos[]){  void * addr=(void *) strtoul(trozos[0],NULL,16);  if (trozos[1]!=NULL){    sacararray(addr,25);  }else{    sacararray(addr,atoi(trozos[1]));  }}/******************************(P3)*******************************/void priority (char *trozos[]){int prioridad=0;  if (trozos[0]!=NULL){    if (trozos[1]!=NULL){      prioridad=atoi(trozos[1]);      if(setpriority(PRIO_PROCESS,atoi(trozos[0]),prioridad)==-1)        perror("Ha fallado: ");      }else{        prioridad=getpriority(PRIO_PROCESS,atoi(trozos[0]));        printf("La prioridad es %d\n",prioridad);      }  }else{      prioridad=getpriority(PRIO_PROCESS,getpid());      printf("La prioridad es %d\n",prioridad);  }}/*****************************************************************/void crearProceso (){ pid_t pid=0;  if ((pid=fork())!=0){    perror("oops: ");  }else    printf("Ejecutando shell en: %d\n", getpid());  waitpid(pid,NULL,0);}/*****************************************************************/void ejecutar (char *trozos[]){  if (strchr(trozos[0],'@')==NULL) {    if (execvp(trozos[0],trozos)==-1) {      perror("Imposible ejecutar");    }  } else {    strcpy(trozos[0],trozos[0]+1);    setpriority(PRIO_PROCESS,getpid(),atoi(trozos[0]));    if(execvp(trozos[1],trozos+1) == -1){      perror("Imposible ejecutar");    }  }}/*****************************************************************/void primPlano(char *trozos[]) {  pid_t pid = 0;  if ((pid=fork())==0) {    ejecutar(trozos);    exit(0);  }  waitpid(pid,NULL,0);}/*****************************************************************/void secPlano(char *trozos[], listaP * lp) {  int i=0;  tItemP item;  char aux[MAXH]="";  pid_t pid = 0;  if ((pid=fork())==0) {    ejecutar(trozos);    exit(0);  }  item.pid=pid;  item.priority= getpriority(PRIO_PROCESS,pid);  while (trozos[i]!=NULL) {    strcat(aux,trozos[i]);    strcat(aux, " ");    i++;  }//  item.estado=  strcpy(item.cmd,aux);  item.fecha=time(NULL);  item.estado=ACTIVO;  insertItemP(lp,item);}/****************************************************************/void updateP(struct node * pos ) {  int estado;  pos->data.priority=getpriority(PRIO_PROCESS,pos->data.pid);  if(pos->data.pid==waitpid(pos->data.pid, &estado,WNOHANG | WUNTRACED | WCONTINUED)){    pos->data.estado=estado;  }  if (WIFSTOPPED(pos->data.estado)) {    pos->data.returned=WSTOPSIG(pos->data.estado);  } else if (WIFEXITED(pos->data.estado)) {    pos->data.returned=WEXITSTATUS(pos->data.estado);  }else if(WIFSIGNALED(pos->data.estado)){    pos->data.returned=WTERMSIG(pos->data.estado);  }}/****************************************************************/void listProcess(struct node * pos) {  tItemP item =getItemP(pos);  char strFecha[50];  struct tm *timer = localtime(&item.fecha);  strftime(strFecha,50,"%a %b %d %H:%M:%S",timer);  printf("%d p=%d %s ",item.pid, item.priority, strFecha );  if (WIFSTOPPED(item.estado)) {    printf("STOPPED (%s) %s\n", NombreSenal(item.returned),item.cmd);  } else if (WIFEXITED(item.estado)) {    printf("TERMINADO (%d) %s\n", item.returned,item.cmd );  } else if(WIFCONTINUED(item.estado)){    printf("ACTIVO %s\n",item.cmd );  }else if(WIFSIGNALED(item.estado)){    printf("SIGNALED (%s) %s\n", NombreSenal(item.returned),item.cmd);  }}/****************************************************************/void listarProcs(listaP *lp){  listaP  pos;  //char strFecha[50];  //struct tm *timer;  if(!isEmptyListP(*lp)){    pos=firstP(*lp);    while (pos!=NULL) {      updateP(pos);      listProcess(pos);      pos=nextP(pos);    }  }}/******************************************************************/void proc(char * trozos[], int nTrozos, listaP * lp) {  listaP pos;  if ((trozos[0]==NULL)||(findItemP(*lp,atoi(trozos[nTrozos-2]))==NULL)) {    listarProcs(lp);  } else {    pos=findItemP(*lp,atoi(trozos[nTrozos-2]));    if ((nTrozos==3)&&(!strcmp(trozos[0],"-fg"))) {      waitpid(pos->data.pid,NULL,0);      deleteItemP(lp,pos);    }else{      updateP(pos);      listProcess(pos);    }  }}/*****************************************************************/void borrarProc(char *trozos[], listaP * lp) {  listaP pos, pre;  if (trozos[0]!=NULL) {    if (!isEmptyListP(*lp)) {      pos=firstP(*lp);      if (!strcmp(trozos[0],"-term")) {        while (pos!=NULL) {          if (pos!=firstP(*lp)) {            pre=previousP(*lp,pos);          }else{            pre=nextP(*lp);          }          updateP(pos);          if (WIFEXITED(pos->data.estado)) {            deleteItemP(lp,pos);            if (pre!=NULL)              pos=pre;            else              pos=firstP(*lp);          }else{              pos=nextP(pos);          }        }      }else if(!strcmp(trozos[0],"-sig")){        while (pos!=NULL) {          if (pos!=firstP(*lp)) {            pre=previousP(*lp,pos);          }else{            pre=nextP(*lp);          }          updateP(pos);          if (WIFSIGNALED(pos->data.estado)){            deleteItemP(lp,pos);            if (pre!=NULL)              pos=pre;            else              pos=firstP(*lp);          }else{              pos=nextP(pos);          }        }      }    }  }else{    listarProcs(lp);  }}/*****************************************************************/int hisLength(char *his[]){ //funcion que devuelve longitud del array  int i=0;  int cont=0;  while (his[i]!=NULL) {      cont++;      i++;  }  return cont;}/******************************************************************/void pointar(char *copia, char *his[]) {  int i=0;    while (his[i]!=NULL) { //vamos hasta la posicion siguiente al ultimo dato introducido      i++;    }    his[i]=strdup(copia); // y almacenamos el comando}/******************************************************************/void emptyHist(char *his[]){ //funcion para vaciar el array  int i=hisLength(his)-1;  while (his[0]!=NULL) {    free(his[i]);    his[i]=NULL;    i--;  }}/*****************************************************************/void hist(char *trozos[], char *his[]) {  int i=0;  if (trozos[0]==NULL) {      while (his[i]!=NULL) {        printf("%s", his[i] );        i++;      }  } else if (!strcmp(trozos[0],"-c")){      emptyHist(his);      printf("Historico Borrado\n");  }}/******************************************************************/void inicializarHistorico(char *his[]) {  for (int i = 0; i < MAXH; i++) {    his[i]=NULL;  }}/*****************************************************************/void printPrompt(){    printf("♠ : ");}/*****************************************************************/void leerEntrada(char *orden){  fgets(orden,MAX,stdin);}/****************************************************************/void procesarEntrada(char *orden,char *trozos[],char *his[], lista * l, listaP * lp) {    char* copia=NULL;    copia=strdup(orden); //almacenamos una copia de la orden del usuario para poder guardarla en el historico    int k = 0, n = TrocearCadena(orden,trozos);    if (*trozos!=NULL)   //comprobamos si se introdujo algo por parte del usuario      pointar(copia, his);  switch (opcion(trozos)) {    case 0:      deleteListP(lp);      emptyHist(his);   //antes de terminar liberamos el historial      free(copia);      exit(0);        break;    case 1:      autores(trozos+1);      break;    case 2:      processID(trozos+1);      break;    case 3:      cdir(trozos+1);      break;    case 4:      fecha();      break;    case 5:      hora();        break;    case 6:        hist(trozos+1,his);        break;    case 7:        printf("\n");            break;    case 9:          crear(trozos+1);            break;    case 10:          borrar(trozos +1);            break;    case 11:          info(trozos,n); //ca,biar esto por trozos +1            break;    case 12:          listar(trozos+1,n);            break;    case 13:          asignar(trozos+1,n,l);            break;    case 14:          desasignar(trozos+1,n,l);            break;    case 15:          recursiva(atoi(trozos[1]));            break;    case 16:          mem(trozos+1,n,l);          break;    case 17:          rfich(trozos+1,n);          break;    case 18:          wfich(trozos+1,n);          break;    case 19:          llenar(trozos+1);          break;    case 20:          volcar(trozos+1);          break;    case 21:          priority(trozos+1);          break;    case 22:          crearProceso();          break;    case 23:          ejecutar(trozos+1);          break;    case 24:          primPlano(trozos +1);          break;    case 25:          secPlano(trozos+1, lp);          break;    case 26:      listarProcs(lp);          break;    case 27:      proc(trozos+1,n,lp);          break;    case 28:      borrarProc(trozos+1,lp);          break;    default:      while (trozos[k]!=NULL) {        k++;      }      if(!strcmp(trozos[k-1],"&")){          trozos[k-1]=NULL;          secPlano(trozos, lp);      }else        primPlano(trozos);      break;    }    while (n!=0) {      trozos[n]=NULL;      n--;    }    free(copia);}/*******************************************************************/int main() {  char orden[MAX];  char *trozos[MAX];  char *his[MAXH];  lista l;  listaP lp;  createList(&l);  createListP(&lp);  inicializarHistorico(his);  while (1) {    printPrompt();    leerEntrada(orden);    procesarEntrada(orden,trozos,his,&l,&lp); //aqui estaba pasando contador  }  return 0;}